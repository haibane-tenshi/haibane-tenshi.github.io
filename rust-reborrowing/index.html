<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>haibane_tenshi&#x27;s blog - Obscure Rust: reborrowing is a half-baked feature</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
      

      
          <link rel="stylesheet" href="https://haibane-tenshi.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Thoughts with wings</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;">Thoughts with wings</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://haibane-tenshi.github.io/rust-reborrowing/#reborrowing" class="toc-link">Reborrowing</a>
                    
                </li>
                
                <li>
                    <a href="https://haibane-tenshi.github.io/rust-reborrowing/#problems" class="toc-link">Problems</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://haibane-tenshi.github.io/rust-reborrowing/#emulating-reborrow" class="toc-link">Emulating reborrow</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://haibane-tenshi.github.io/rust-reborrowing/#alternative-view" class="toc-link">Alternative view</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://haibane-tenshi.github.io/rust-reborrowing/#scope-expansion" class="toc-link">Scope expansion</a>
                        </li>
                        
                        <li>
                            <a href="https://haibane-tenshi.github.io/rust-reborrowing/#implications" class="toc-link">Implications</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://haibane-tenshi.github.io/rust-reborrowing/#conclusions" class="toc-link">Conclusions</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;rust-reborrowing&#x2F;">Obscure Rust: reborrowing is a half-baked feature</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2022-06-26</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>Let's start with simple motivating use case.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">mutate</span><span>(</span><span style="color:#bf616a;">i</span><span>: &amp;</span><span style="color:#b48ead;">mut u32</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">mut u32 </span><span>{</span><span>
</span><span>    *i += </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>    i</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">mutate_twice</span><span>(</span><span style="color:#bf616a;">i</span><span>: &amp;</span><span style="color:#b48ead;">mut u32</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">mut u32 </span><span>{</span><span>
</span><span>    </span><span style="color:#96b5b4;">mutate</span><span>(i);</span><span>
</span><span>    </span><span style="color:#96b5b4;">mutate</span><span>(i)</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This innocuous example hides a huge can of worms behind apparent simplicity.</p>
<p><code>&amp;mut T</code> implements neither <code>Copy</code> nor <code>Clone</code> - and it makes sense, copying unique reference aliases it.
It means mutable references are move-only, so first call to <code>mutate</code> consumes <code>i</code>.
But then how does the second call to <code>mutate</code> works?!
The answer is in the title: reborrowing.</p>
<h1 id="reborrowing">Reborrowing</h1>
<p>Let's take a slightly simpler example.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> num = </span><span style="color:#d08770;">32_</span><span style="color:#b48ead;">u32</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">let</span><span> a = &amp;</span><span style="color:#b48ead;">mut</span><span> num;</span><span>
</span><span style="color:#b48ead;">let</span><span> b: &amp;</span><span style="color:#b48ead;">mut </span><span>_ = a;</span><span>
</span><span>*b += </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>*a += </span><span style="color:#d08770;">1</span><span>;</span><span>
</span></code></pre>
<p>To make this work, compiler inserts a reborrow on your behalf:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> b: &amp;</span><span style="color:#b48ead;">mut </span><span>_ = &amp;</span><span style="color:#b48ead;">mut </span><span>*a;</span><span>
</span><span style="color:#65737e;">//              ^^^^^^</span><span>
</span></code></pre>
<p>It seems like just a new reference is created, but in fact it does something much more interesting.
There can exist only one mutable borrow, and to achieve that parent borrow <code>a</code> is suspended,
then <code>b</code> becomes an active borrow in its stead.
There is no problem with us using <code>b</code> at this point as compiler knows that this is the only borrow that <em>can</em> be used:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> num = </span><span style="color:#d08770;">32_</span><span style="color:#b48ead;">u32</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">let</span><span> a = &amp;</span><span style="color:#b48ead;">mut</span><span> num;</span><span>
</span><span style="color:#b48ead;">let</span><span> b: &amp;</span><span style="color:#b48ead;">mut </span><span>_ = a; </span><span style="color:#65737e;">// Create reborrow</span><span>
</span><span>*b += </span><span style="color:#d08770;">1</span><span>;           </span><span style="color:#65737e;">// `b` has all privileges, so we can use it</span><span>
</span><span>                   </span><span style="color:#65737e;">// `b` goes out of scope</span><span>
</span><span>*a += </span><span style="color:#d08770;">1</span><span>;           </span><span style="color:#65737e;">// It is OK to use `a` again</span><span>
</span></code></pre>
<p>However, this works only as long as <code>a</code> is inactive.
If you try to use <code>a</code> while <code>b</code> is still alive...</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> num = </span><span style="color:#d08770;">32_</span><span style="color:#b48ead;">u32</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">let</span><span> a = &amp;</span><span style="color:#b48ead;">mut</span><span> num;</span><span>
</span><span style="color:#b48ead;">let</span><span> b: &amp;</span><span style="color:#b48ead;">mut </span><span>_ = a;</span><span>
</span><span>*a += </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// Mutation order is changed</span><span>
</span><span>*b += </span><span style="color:#d08770;">1</span><span>; </span><span>
</span></code></pre>
<p>...you will be greeted with <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=1190c9555095a3fe8b245938c0a745a0">angry compiler messages</a>.</p>
<p>Last thing to mention, there is a number of places where <a href="https://doc.rust-lang.org/stable/reference/expressions.html?highlight=implicit,borrows#implicit-borrows">implicit borrows</a>
can be inserted, but it can only happen when compiler is aware that a reference is expected.
For example, generic non-reference parameters are <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=dd76f60c941e526083f92c6aa3478636">not automatically reborrowed</a>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">take</span><span>&lt;T&gt;(_: T) {}</span><span>
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> num = </span><span style="color:#d08770;">3_</span><span style="color:#b48ead;">usize</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">let</span><span> a = &amp;</span><span style="color:#b48ead;">mut</span><span> num;</span><span>
</span><span style="color:#96b5b4;">take</span><span>(a);</span><span>
</span><span style="color:#96b5b4;">take</span><span>(a); </span><span style="color:#65737e;">// Uh-oh</span><span>
</span></code></pre>
<p>But it is always possible to achieve this <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=1c9c87689289cb39cbbccf37ebb98394">manually</a>.</p>
<h1 id="problems">Problems</h1>
<p>That concludes the short prelude, let's talk business.
There are glaring issues with this model of reborrowing.
More specifically, there is one problem that was annoying me for the better part of last few months:</p>
<blockquote>
<p>Reborrowing cannot be expressed in type system.</p>
</blockquote>
<p>I.e. we cannot abstract over it.</p>
<p>This may sound controversial.
People seemingly tried this <a href="https://stackoverflow.com/questions/43036156/how-can-i-reborrow-a-mutable-reference-without-passing-it-to-a-function">for years</a>,
there is even <a href="https://docs.rs/reborrow/latest/reborrow/">a crate</a> doing just that.
Is it all a lie?
Well, sort of.</p>
<h2 id="emulating-reborrow">Emulating reborrow</h2>
<p>We will be talking only about mutable references from now on, as this is the interesting case.</p>
<p>Every attempt at expressing reborrow in type system boils down to writing a function
which transforms <code>&amp;mut &amp;mut T</code> into <code>&amp;mut T</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">reborrow</span><span>&lt;</span><span style="color:#b48ead;">&#39;a</span><span>, </span><span style="color:#b48ead;">&#39;b</span><span>, T&gt;(</span><span style="color:#bf616a;">r</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a mut </span><span>&amp;</span><span style="color:#b48ead;">&#39;b mut</span><span> T) -&gt; &amp;</span><span style="color:#b48ead;">&#39;a mut</span><span> T {</span><span>
</span><span>    r</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This should look familiar: <code>Clone::clone</code> is very similar in both structure and rationale.
We want to keep original reference intact, so we pass it by reference (resulting in double reference).
Also, outer reference needs to be mutable, so that compiler is able to infer uniqueness of resulting reference.</p>
<p>The cool part, <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=3c0b652692a370b4186764424122991c">it works</a>!</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> num = </span><span style="color:#d08770;">32_</span><span style="color:#b48ead;">u32</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> a = &amp;</span><span style="color:#b48ead;">mut</span><span> num;</span><span>
</span><span style="color:#b48ead;">let</span><span> b: &amp;</span><span style="color:#b48ead;">mut </span><span>_ = </span><span style="color:#96b5b4;">reborrow</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> a);</span><span>
</span><span>*b += </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>*a += </span><span style="color:#d08770;">1</span><span>;</span><span>
</span></code></pre>
<p>Which gives a naughty feeling as if we slandered the type system by doing the impossible.
<em>Except</em>, this approach is imperfect.
Remember example at the start?
It <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=a411b9c755033d2f296478eb49c2d227">no longer compiles</a>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">mutate_twice</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">i</span><span>: &amp;</span><span style="color:#b48ead;">mut u32</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">mut u32 </span><span>{</span><span>
</span><span>    </span><span style="color:#96b5b4;">mutate</span><span>(</span><span style="color:#96b5b4;">reborrow</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> i));</span><span>
</span><span>    </span><span style="color:#96b5b4;">mutate</span><span>(</span><span style="color:#96b5b4;">reborrow</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> i))</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>:(</p>
<blockquote>
<p>As pointed out by /u/reflexpr-sarah- this example is actually not identical to original one:
in the original, second call to <code>mutate</code> actually <em>moves</em> <code>i</code> in, so there is no reborrow happening.
If you remove the second call to <code>reborrow</code>, example actually <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=06141d86ba25e194a2864568882560b8">compiles</a>.</p>
<p>I was trying to be clever here, and got called out.
In theory, for this problem to happen we need to return reference to local variable.
However, as long as compiler can statically deduce that use on return statement is indeed the last one,
reborrow turns into a move.
We can force reborrow by making sure that return statement is decided at runtime,
for example using <code>if</code>s or <code>loop</code>s...
but then Rust just requires for borrow to exist for the scope of the whole function
which squashes all subsequent uses and therefore removes reborrow.
This is also known as <code>get_or_create</code> pattern.</p>
<p>Summarizing, I don't think it is possible to make it fail in <em>current</em> Rust,
but with addition of <a href="https://github.com/rust-lang/polonius">Polonius</a> or further improvements to borrow checker this is likely to manifest.</p>
</blockquote>
<h1 id="alternative-view">Alternative view</h1>
<p>It isn't trivial to rationalize this difference in behavior,
so here's my personal mental model of lifetimes.
It doesn't pretend on anything, but it makes the problem we ran into above painfully visible.</p>
<p>Every lifetime is a link between data (place in memory) and
referent (shared/mutable reference) which grants access to it.
We can imagine that lifetime is combination of <em>two</em> scopes, not one:</p>
<ul>
<li><em>liveness</em> scope - which delimits how long data exists, and</li>
<li><em>referential</em> scope - which delimits how long referent can be used.</li>
</ul>
<p>The separation is surprisingly clean.
Every scope has its own responsibility and those are orthogonal to each other.</p>
<p>Purpose of <em>liveness</em> scope is to ensure that we access alive objects,
i.e. to prevent use-after-free and uninitialized memory access.
The scope is property of data and is effectively immutable.
There is nothing you can do through a reference to shorten/lengthen lifetime of underlying data,
and Rust prevents us from dropping the data prematurely as long as any referents exist.</p>
<p>Purpose of <em>referential</em> scope is to ensure aliasing rules.
Unfortunately, simply scoping references is not enough, so we get complicated interaction rules and
this is the reason for <a href="https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md">Stacked Borrows</a> to exist.
One of the most important properties of <em>referential</em> scopes is ability to be narrowed
to allow multiple references to coexist.</p>
<p>It is also plain to see that those two scopes barely interact.
Since liveness scope is immutable it is just carried around and inherited by derived lifetimes,
and referential scope can contract or even expand at will - as long as it stays within liveness scope.</p>
<p>Here's an interesting observation: in current Rust those two scopes are almost always identical.
And, that's right, reborrowing is the reason for the <em>almost</em> part.
Reborrowing creates a new reference which keeps liveness scope intact but has narrower referential scope.
It allows lifetime to properly interact with aliasing analysis, without losing information about 
how long data actually lives. 
This operation is notably unique.
No other language feature allows us to separate the two scopes.</p>
<p>Inventing new questionable syntax, if <code>'l</code> is liveness scope, <code>'r</code> is referential scope and
<code>'l+'r</code> is combined actual lifetime, we can express true reborrowing as:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">true_reborrow</span><span>&lt;</span><span style="color:#b48ead;">&#39;l</span><span>, </span><span style="color:#b48ead;">&#39;r0</span><span>, </span><span style="color:#b48ead;">&#39;r1</span><span>, T&gt;(&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut </span><span>&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r0 mut</span><span> T) -&gt; &amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut</span><span> T;</span><span>
</span></code></pre>
<p>As opposed to emulation attempt we did earlier:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">reborrow</span><span>&lt;</span><span style="color:#b48ead;">&#39;l</span><span>, </span><span style="color:#b48ead;">&#39;r0</span><span>, </span><span style="color:#b48ead;">&#39;r1</span><span>, T&gt;(&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut </span><span>&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r0 mut</span><span> T) -&gt; &amp;</span><span style="color:#b48ead;">&#39;r1</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut</span><span> T;</span><span>
</span><span style="color:#65737e;">//                                                          ^^^</span><span>
</span><span style="color:#65737e;">//                                 liveness information is lost!</span><span>
</span></code></pre>
<h2 id="scope-expansion">Scope expansion</h2>
<p>If it did end there, the model wouldn't be particularly useful.
However, it supports somewhat unnatural operation: referential scope expansion.</p>
<p>Let's annotate original example:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">mutate_twice</span><span>(</span><span style="color:#bf616a;">i</span><span>: &amp;</span><span style="color:#b48ead;">mut u32</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">mut u32 </span><span>{ </span><span>
</span><span>    </span><span style="color:#65737e;">// i belongs to scope &#39;0</span><span>
</span><span>    </span><span style="color:#65737e;">// return type is expected to be the same</span><span>
</span><span>    </span><span>
</span><span>    </span><span style="color:#96b5b4;">mutate</span><span>(i);         </span><span style="color:#65737e;">// reborrow for scope &#39;1</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> r = </span><span style="color:#96b5b4;">mutate</span><span>(i); </span><span style="color:#65737e;">// reborrow for scope &#39;2</span><span>
</span><span>                       </span><span style="color:#65737e;">// r inherits the scope &#39;2</span><span>
</span><span>    </span><span>
</span><span>    r                  </span><span style="color:#65737e;">// we return reference with scope &#39;2</span><span>
</span><span>                       </span><span style="color:#65737e;">// as if it belongs to scope &#39;0! </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>The last line is interesting.
<code>r</code> is reference with associated lifetime <code>'l+'2</code>, but function is expected to return reference with <code>'l+'0</code>!
We implicitly expanded the referential scope to fit function signature.</p>
<p>How valid is such operation?</p>
<p>Both references share <em>liveness</em> scope, so no memory-related problems to be had here.
From perspective of <em>referential</em> scopes, as long as aliasing rules are not broken everything is fine.
We can see that original <code>i</code> is no longer used, so this definitely holds.
You can imagine that <code>r</code> assumed <code>'0</code> scope by rendering <code>i</code> inaccessible.</p>
<p>Summarizing, referential scope narrowing is <em>reversible</em>.
This is where the emulation attempt fails spectacularly.
If we look at the pseudo-signature another time...</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">reborrow</span><span>&lt;</span><span style="color:#b48ead;">&#39;l</span><span>, </span><span style="color:#b48ead;">&#39;r0</span><span>, </span><span style="color:#b48ead;">&#39;r1</span><span>, T&gt;(&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut </span><span>&amp;</span><span style="color:#b48ead;">&#39;l</span><span>+</span><span style="color:#b48ead;">&#39;r0 mut</span><span> T) -&gt; &amp;</span><span style="color:#b48ead;">&#39;r1</span><span>+</span><span style="color:#b48ead;">&#39;r1 mut</span><span> T;</span><span>
</span></code></pre>
<p>...recovering original reference would mean converting <code>'r1+'r1</code> lifetime into <code>'l+'r1</code>,
but it is considered taboo by compiler!
Expanding liveness scope certainly leads to memory problems, so it is flat forbidden.</p>
<h2 id="implications">Implications</h2>
<p>My biggest gripe with current state of reborrowing in that it is so tightly coupled to references.
<strong>Reborrowing is about manipulating lifetime scopes to assist aliasing analysis</strong>,
it isn't just a gimmick to sneakily manage mutable references!
This is a fundamental operation inside type system and should be treated as such.</p>
<p>The coupling spells a lot of trouble.
Custom types parametrized on lifetimes cannot be reborrowed.
Given type...</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>MyRef&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt;(&amp;</span><span style="color:#b48ead;">&#39;a mut </span><span>());</span><span>
</span></code></pre>
<p>...the only way to reborrow one is to destructure, reborrow inner reference and reconstruct the value,
provided you have access to innards.
And you cannot even move operation outside current function:
reborrow must be used from the same scope where it was created.
Nightmare fuel.</p>
<p>It gets worse yet.
If the type is hidden behind generic parameter <code>T</code> it is just over.
There is <em>nothing</em> you can do to tap into true reborrowing.
Emulation while cute is sorely inadequate as a replacement.</p>
<p><code>unsafe</code> is maybe heralded as an escape hatch, but it fails miserably to resolve the situation
because converting references to pointers erases all lifetime information.
This is not what we want.</p>
<p>And this is exactly the edge case I ran into.</p>
<p>Also, as a tangent, I wonder if this is a part of why lifetimes are confusing to newcomers.
We have two different meanings and semantics jumbled into single object.
Teaching resources often treat it as one or the other depending on situation, which doesn't add clarity.</p>
<h1 id="conclusions">Conclusions</h1>
<p>I don't know what conclusions to make here.
It is obvious that 99.9% of Rust ecosystem doesn't care about this.
Trying to fix lifetimes considering backwards compatibility and all related work is maddeningly complicated.
Unfortunately, I have hard time imagining contexts work in practice without solving this issue.
I also wonder what other potential applications are inhibited by current situation.</p>
<p>Anyways, have a good day, and see you next time!</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://haibane-tenshi.github.io/tags/rust/">#rust</a>
                    
                        <a href="https://haibane-tenshi.github.io/tags/reborrowing/">#reborrowing</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;rust-early-and-late-bound-generics&#x2F;">‹ Obscure Rust: early- and late-bound generics in functions</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;haibane-tenshi.github.io&#x2F;rust-contexts2&#x2F;">Futuristic Rust: context emulation, part 2 ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://haibane-tenshi.github.io/even.js" ></script>
      
    </body>

</html>
